#!/usr/bin/env python3

"""
Some of this code is taken by https://github.com/DestructiveVoice/DestructiveFarm/blob/master/client/start_sploit.py
And that's the reason why this submitter is called "exploitfarm"
"""

import dateutil.parser
import os, re, orjson
import subprocess, time, threading, traceback
from concurrent.futures import ThreadPoolExecutor
from math import ceil
from exploitfarm.utils.config import ClientConfig, ExploitConfig
from multiprocessing import Queue
from datetime import datetime, UTC, timedelta
from exploitfarm.model import AttackExecutionStatus, AttackMode
from rich import print
from uuid import UUID

os_windows = (os.name == 'nt')

class g:
    pool_size:int = 50
    config: ClientConfig = None
    shared_memory: dict = None
    submit_pool_timeout: int = 3
    server_status_refresh_period: int = 5
    exploit_config: ExploitConfig = None
    print_queue: Queue = None
    last_attack_time: datetime = None
    config_update_event:Queue = Queue()
    flag_storage:"FlagStorage" = None 
    instance_storage:"InstanceStorage" = None

class InstanceStorage:
    """
    Storage comprised of a dictionary of all running sploit instances and some statistics.

    Always acquire instance_lock before using this class. Do not release the lock
    between actual spawning/killing a process and calling register_start()/register_stop().
    """

    def __init__(self):
        self._counter = 0
        self._instances = {}

        self.n_completed = 0
        self.n_killed = 0
        self.lock = threading.RLock()

    @property
    def instances(self):
        with self.lock:
            return self._instances

    def register_start(self, process):
        with self.lock:
            instance_id = self._counter
            self._instances[instance_id] = process
            self._counter += 1
            return instance_id

    def register_stop(self, instance_id, was_killed):
        with self.lock:
            del self._instances[instance_id]

            self.n_completed += 1
            self.n_killed += was_killed

class FlagStorage:
    """
    Thread-safe storage comprised of a set and a post queue.

    Any number of threads may call add(), but only one "consumer thread"
    may call pick_flags() and mark_as_sent().
    """

    def __init__(self, client_id: UUID|None = None):
        self._queue = []
        self._lock = threading.RLock()
        self.client_id = client_id

    def add(self,
        flags: list[str],
        team: int,
        start_time: datetime,
        end_time: datetime,
        status: AttackExecutionStatus,
        output: bytes,
    ):
        team_info_list = g.shared_memory.get(f"team-{team}", [])
        information_to_submit = {
            "start_time": start_time,
            "end_time": end_time,
            "status": status.value,
            "error": None if status == AttackExecutionStatus.done else output,
            "executed_by": self.client_id,
            "target": team,
            "flags": flags
        }
        team_info_list.append(information_to_submit)
        g.shared_memory[f"team-{team}"] = team_info_list
        with self._lock:
            self._queue.append(information_to_submit)

    def pick_flags(self):
        with self._lock:
            return self._queue[:]

    def mark_as_sent(self, count):
        with self._lock:
            self._queue = self._queue[count:]

    @property
    def queue_size(self):
        with self._lock:
            return len(self._queue)

WARNING_RUNTIME = 5

def qprint(*args):
    for arg in args:
        g.print_queue.put(arg, block=False)

class InvalidSploitError(Exception):
    pass


if os_windows:
    # By default, Ctrl+C does not work on Windows if we spawn subprocesses.
    # Here we fix that using WinApi. See https://stackoverflow.com/a/43095532

    import signal
    import ctypes
    from ctypes import wintypes

    kernel32 = ctypes.WinDLL("kernel32", use_last_error=True)

    # BOOL WINAPI HandlerRoutine(
    #   _In_ DWORD dwCtrlType
    # );
    PHANDLER_ROUTINE = ctypes.WINFUNCTYPE(wintypes.BOOL, wintypes.DWORD)

    win_ignore_ctrl_c = PHANDLER_ROUTINE()  # = NULL

    def _errcheck_bool(result, _, args):
        if not result:
            raise ctypes.WinError(ctypes.get_last_error())
        return args

    # BOOL WINAPI SetConsoleCtrlHandler(
    #   _In_opt_ PHANDLER_ROUTINE HandlerRoutine,
    #   _In_     BOOL             Add
    # );
    kernel32.SetConsoleCtrlHandler.errcheck = _errcheck_bool
    kernel32.SetConsoleCtrlHandler.argtypes = (PHANDLER_ROUTINE, wintypes.BOOL)

    @PHANDLER_ROUTINE
    def win_ctrl_handler(dwCtrlType):
        if dwCtrlType == signal.CTRL_C_EVENT:
            kernel32.SetConsoleCtrlHandler(win_ignore_ctrl_c, True)
            shutdown()
        return False

    kernel32.SetConsoleCtrlHandler(win_ctrl_handler, True)


class APIException(Exception):
    pass

def once_in_a_period(period):
    iter_no = 1
    while(True):
        start_time = time.time()
        yield iter_no

        time_spent = time.time() - start_time
        if period > time_spent:
            time.sleep(period - time_spent)
        iter_no += 1

def update_server_config():
    try:
        for _ in once_in_a_period(g.server_status_refresh_period):
            try:
                g.config.fetch_status()
                if g.config.status:
                    if not g.config.status["loggined"]:
                        qprint('Not loggined, login first to get the config and run the exploit')
                        exit(1)
                    new_conf = g.config.status
                    old_conf = g.shared_memory["config"]
                    if old_conf.get("server_time", None):
                        del old_conf["server_time"];
                    if new_conf.get("server_time", None):
                        del new_conf["server_time"];
                    if new_conf != old_conf:
                        qprint('Config updated', new_conf)
                        g.shared_memory["config"] = new_conf
                        g.config_update_event.put("update", block=False)
            except Exception as e:
                qprint(traceback.format_exc())
                qprint(f"Can't get config from the server: {repr(e)}")
    except Exception as e:
        qprint(traceback.format_exc())
        qprint(f'Config update loop died: {repr(e)}')
        shutdown()

def post_flags(flags):
    try:
        g.config.reqs.submit_flags(flags, exploit=g.exploit_config.uuid)
        g.flag_storage.mark_as_sent(len(flags))
        flags = sum([len(x["flags"]) for x in flags])
        qprint(f'{flags} flags posted to the server ({g.flag_storage.queue_size} in the queue)')
    except Exception as e:
        qprint(traceback.format_exc())
        qprint(f"Can't post flags to the server: {repr(e)}")

def run_post_loop():
    try:
        for _ in once_in_a_period(g.submit_pool_timeout):
            flags_to_post = g.flag_storage.pick_flags()
            if flags_to_post: post_flags(flags_to_post)
    except Exception as e:
        qprint(traceback.format_exc())
        qprint(f'Posting loop died: {repr(e)}')
        shutdown()

def process_sploit_filter(proc:subprocess.Popen, team: dict, start_time: datetime, killed: bool):
    try:
        end_time = datetime.now(UTC)
        output = proc.stdout.read()
        qprint(f"Output of the sploit of {team} started: {start_time} ended: {end_time}\n{output.decode('utf-8', errors='replace')}")
        config = g.shared_memory["config"]
        flag_format = re.compile(config["config"]["FLAG_REGEX"].encode())
        flags = list(map(str, set(flag_format.findall(output))))
        
        if isinstance(output, bytes):
            output = output.decode('utf-8', errors='replace')
        
        if killed or proc.returncode != 0:
            if killed:
                output = b"THIS PROCESS HAS BEEN KILLED BY EXPLOITFARM DUE TO TIMEOUT\n-------- OUTPUT -------\n\n" + output
            g.flag_storage.add(flags, team["id"], start_time, end_time, AttackExecutionStatus.crashed, output)
        if flags:
            g.flag_storage.add(flags, team["id"], start_time, end_time, AttackExecutionStatus.done, b'')
        else:
            g.flag_storage.add(flags, team["id"], start_time, end_time, AttackExecutionStatus.noflags, output)
    except Exception as e:
        qprint(traceback.format_exc())
        qprint(f'Failed to process sploit output: {repr(e)}')

def launch_sploit(team:dict, max_runtime:float):
    # For sploits written in Python, this env variable forces the interpreter to flush
    # stdout and stderr after each newline. Note that this is not default behavior
    # if the sploit's output is redirected to a pipe.
    env = os.environ.copy()
    env['PYTHONUNBUFFERED'] = '1'
    env["XFARM_HOST"] = team["host"]
    env["XFARM_TEAM"] = orjson.dumps(team)
    env["XFARM_RUNTIME"] = str(max_runtime)
    
    try:
        config = g.shared_memory["config"]
        services = config["services"]
        services = list(filter(lambda x: x["id"] == str(g.exploit_config.service), services))
        if len(services) > 0:
            env["XFARM_SERVICE"] = orjson.dumps(services[0])        
    except Exception as e:
        qprint(f"Can't get service info: {repr(e)}")

    command = f"{g.exploit_config.interpreter} {g.exploit_config.run}".strip()
    need_close_fds = (not os_windows)

    if os_windows:
        # On Windows, we block Ctrl+C handling, spawn the process, and
        # then recover the handler. This is the only way to make Ctrl+C
        # intercepted by us instead of our child processes.
        kernel32.SetConsoleCtrlHandler(win_ignore_ctrl_c, True)

    proc = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, close_fds=need_close_fds, env=env, shell=True)
    if os_windows:
        kernel32.SetConsoleCtrlHandler(win_ignore_ctrl_c, False)

    return proc, g.instance_storage.register_start(proc)


def run_sploit(team:dict, max_runtime:float):
    start_time = datetime.now(UTC)
    try:
        g.shared_memory["team-"+str(team["id"])+"-executing"] = True
        proc, instance_id = launch_sploit(team, max_runtime)
    except Exception as e:
        if isinstance(e, FileNotFoundError):
            qprint(f'Sploit file or the interpreter for it not found: {repr(e)}')
        else:
            qprint(traceback.format_exc())
            qprint(f'Failed to run sploit: {repr(e)}')
        return

    try:
        try:
            proc.wait(timeout=max_runtime)
            need_kill = False
        except subprocess.TimeoutExpired:
            need_kill = True
        with g.instance_storage.lock:
            if need_kill:
                proc.kill()
        g.shared_memory["team-"+str(team["id"])+"-executing"] = False
        process_sploit_filter(proc, team, start_time, need_kill)
        g.instance_storage.register_stop(instance_id, need_kill)
    except Exception as e:
        qprint(traceback.format_exc())
        qprint(f'Failed to finish sploit: {repr(e)}')

def next_timout() -> float|int:
    config = g.shared_memory["config"]
    attack_mode = AttackMode(config["config"]["ATTACK_MODE"])
    this_time = datetime.now(UTC)
    if not g.last_attack_time:
        return 0 #Start the attack immediately
    match attack_mode:
        case AttackMode.TICK_DELAY:
            timeout = config["config"]["TICK_DURATION"] - (this_time - g.last_attack_time).total_seconds()
            return timeout if timeout > 0 else 0
        case AttackMode.WAIT_FOR_TIME_TICK:
            start_time = dateutil.parser.parse(config["config"]["START_TIME"])
            tick = 1
            next_time:datetime = None
            if start_time > this_time:
                qprint("Waiting for the start time")
                return (start_time - this_time).total_seconds()
            while True:
                next_time = start_time + timedelta(seconds=config["config"]["TICK_DURATION"] * tick) + timedelta(seconds=config["config"]["ATTACK_TIME_TICK_DELAY"])
                if next_time > g.last_attack_time:
                    break
                tick += 1
            return (next_time - g.last_attack_time).total_seconds()            
        case AttackMode.LOOP_DELAY:
            timeout = config["config"]["LOOP_ATTACK_DELAY"] - (this_time - g.last_attack_time).total_seconds()
            return timeout if timeout > 0 else 0
    
def calc_runtime_timeout():
    config = g.shared_memory["config"]
    teams = len(config["teams"])
    if teams == 0:
        return 0
    result = config["config"]["TICK_DURATION"] / ceil(teams / g.pool_size)
    if result < WARNING_RUNTIME:
        qprint(f"⚠️ WARNING: The runtime of the attack is too low: {result} seconds, consider increasing the number thread pool size")
    return result

def xploit(path: str):
    os.chdir(path)
    threading.Thread(target=run_post_loop).start()
    threading.Thread(target=update_server_config).start()
    pool = ThreadPoolExecutor(max_workers=g.pool_size)
    try:
        while True:
            max_runtime = calc_runtime_timeout()
            g.shared_memory["runtime_timeout"] = max_runtime
            if g.instance_storage.n_completed > 0:
                qprint('Total {:.1f}% of instances ran out of time'.format(
                    float(g.instance_storage.n_killed) / g.instance_storage.n_completed * 100))
            for team in g.shared_memory["config"]["teams"]:
                if g.shared_memory.get("team-"+str(team["id"])+"-enabled", True):
                    pool.submit(run_sploit, team, max_runtime)
            
            g.last_attack_time = datetime.now(UTC)
            try:
                timeout = next_timout()
                g.shared_memory["next_timeout"] = timeout
                g.shared_memory["last_attack"] = g.last_attack_time
                qprint(f"--> Next attacks will be in {timeout} seconds")
                g.config_update_event.get(timeout=timeout) #If the config is updated, all attacks will be "restarted"
            except Exception:
                pass
    except (KeyboardInterrupt, RuntimeError):
        pass
    finally:
        shutdown()

def run_printer_queue():
    try:
        while True:
            print(g.print_queue.get())
    except Exception:
        pass

def shutdown():
    g.config_update_event.put("shutdown", block=False)
    # Kill all child processes (so consume_sploit_ouput and run_sploit also will stop)
    for proc in g.instance_storage.instances.values():
        proc.kill()
    os._exit(0)

def xploit_one(config: ClientConfig, team: str, path: str, timeout: float = 30):
    g.config = config
    g.shared_memory = {
        "config": g.config.status.copy()
    }
    g.exploit_config = ExploitConfig.read(path)
    g.print_queue = Queue()
    g.flag_storage = FlagStorage(config.client_id)
    g.instance_storage = InstanceStorage()
    threading.Thread(target=run_printer_queue).start()
    run_sploit({"id":0, "host":team}, timeout)
    flags = g.flag_storage.pick_flags()[0]["flags"]
    g.config.reqs.submit_flags({"flags":flags})
    g.print_queue.close()
    print(f"Submitted {len(flags)} flags as manual submissions.")


def start_xploit(config: ClientConfig, shared_dict:dict, print_queue: Queue, pool_size:int=50, path:str="./", submit_pool_timeout:int=3, server_status_refresh_period: int = 5) -> threading.Thread:
    
    g.config = config
    g.pool_size = pool_size
    g.shared_memory = shared_dict
    g.submit_pool_timeout = submit_pool_timeout
    g.server_status_refresh_period = server_status_refresh_period
    g.exploit_config = ExploitConfig.read(path)
    g.print_queue = print_queue
    g.flag_storage = FlagStorage(config.client_id)
    g.instance_storage = InstanceStorage()
    
    thr = threading.Thread(target=xploit, args=(path,))
    thr.start()
    return thr