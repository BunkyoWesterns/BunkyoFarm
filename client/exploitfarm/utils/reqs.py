import requests, os
from uuid import UUID
from typing import Dict, Any
from exploitfarm.utils import ClientConfig

HTTP_TIMEOUT = int(os.getenv("XFARM_HTTP_TIMEOUT", 3))
PATH_OFFSET = os.getenv("XFARM_PATH_OFFSET", "/api")

def get_url(path:str, config: ClientConfig|None = None) -> str:
    return f"http{'s' if config.server.https else ''}://{config.server.address}:{config.server.port}"+os.path.join("/", PATH_OFFSET, path[1:] if path.startswith('/') else path)

def get_session(auth:str|None|ClientConfig = None) -> requests.Session:
    res = requests.Session()
    if auth is not None:
        if isinstance(auth, str):
            res.headers.update({"Authorization": "Bearer "+auth})
        elif isinstance(auth, ClientConfig) and auth.server.auth_key is not None:
            res.headers.update({"Authorization": "Bearer "+auth.server.auth_key})
    return res

class ReqsError(Exception):pass

def requests_check(res: Dict) -> Any:
    if res["status"] != "ok":
        raise ReqsError(res["message"])
    else:
        return res["response"]

class Reqs:
    def __init__(self, config: ClientConfig):
        self.config = config
        self.session = get_session(config)
    
    def refresh_session(self, auth:str|ClientConfig|None = None):
        self.session = get_session(auth if auth else self.config)
    
    def status(self) -> Dict[str, Any]:
        res = self.session.get(get_url("/status", self.config), timeout=HTTP_TIMEOUT).json()
        try:
            if res["whoami"] != "exploitfarm":
                raise Exception()
        except Exception:
            raise ReqsError("Invalid server")
        return res
            
    
    def submitter(self, data: dict) -> Any:
        return requests_check(self.session.post(get_url("/submitters", self.config), json=data, timeout=HTTP_TIMEOUT).json())
    
    def setup(self, data: dict) -> Any:
        return requests_check(self.session.post(get_url("/setup", self.config), json=data, timeout=HTTP_TIMEOUT).json())
    
    def login(self,password:str) -> str:
        try:
            return self.session.post(get_url("/login", self.config), data={"grant_type":"password", "username": "user", "password": password}, timeout=HTTP_TIMEOUT).json()["access_token"]
        except KeyError:
            raise ReqsError("Failed to login")
    
    def authenicate(self, password:str) -> str:
        auth_key = self.login(password)
        self.refresh_session(auth_key)
        status = self.status()
        self.refresh_session(status.get("auth_key", None))
    
    def new_client(self, data: dict) -> Any:
        return requests_check(self.session.post(get_url("/clients", self.config), json=data, timeout=HTTP_TIMEOUT).json())
    
    def self_subscribe_client(self) -> Any:
        return self.new_client({"name": self.config.client_name, "id": self.config.client_id})
            
    def new_teams(self, data: list) -> Any:
        return requests_check(self.session.post(get_url("/teams", self.config), json=data, timeout=HTTP_TIMEOUT).json())
    
    def new_service(self, data: dict) -> Any:
        return requests_check(self.session.post(get_url("/services", self.config), json=data, timeout=HTTP_TIMEOUT).json())
    
    def submit_flags(self, data: dict, exploit:UUID|None = None) -> Any:
        if not exploit:
            return requests_check(self.session.post(get_url("/exploits/submit", self.config), json=data, timeout=HTTP_TIMEOUT).json())
        else:
            return requests_check(self.session.post(get_url(f"/exploits/{exploit}/submit", self.config), json=data, timeout=HTTP_TIMEOUT).json())

