from textual.app import App, ComposeResult
from textual.widgets import Footer, RichLog, Tab, Tabs, DataTable, Header, Label
from textual.widgets.data_table import CellDoesNotExist
from exploitfarm.utils.config import ExploitConfig
from exploitfarm.models.enums import AttackExecutionStatus
from datetime import datetime as dt
import datetime
from rich.text import Text
from rich.markup import escape
import traceback
import psutil
from copy import deepcopy
from exploitfarm.utils import mem_usage
from exploitfarm import Prio, nicenessify
from exploitfarm.xploit import shutdown
from exploitfarm.utils.config import AttackStartConfig, TeamInfo

class g:
    exec: AttackStartConfig
    exploit_config: ExploitConfig

def stop_screen():
    g.exec.exit_event.set()
    shutdown()
    g.exec.print_queue.put("Stopping exploit execution..")

def start_exploit_tui(exec_info: AttackStartConfig, exploit_config: ExploitConfig):
    g.exec = exec_info
    g.exploit_config = exploit_config
    nicenessify(Prio.normal)
    XploitRun().run()
    stop_screen()

class XploitRun(App[int]):
    
    def __init__(self):
        super().__init__()
        self.title = f"xFarm - Exploit execution of {g.exploit_config.name}"          
    
    BINDINGS = [
        ("ctrl+c", "cancel()", "Close attack"),
        ("1", "show_tab('Teams')", "Show teams"),
        ("2", "show_tab('Log')", "Show logs"),
    ]
    
    CSS = """
        .hidden {
            display: none;
        }
        .tab {
            width: 100%;
        }
        .tab-Log {
            align: center middle;
        }
        .tab-Teams {
            align: center middle;
            height: 1fr;
        }
        .full-width {
            width: 100%;
        }
        #status_text{
            height: 5;
        }
    """
    
    TABS = [
        Tab("Teams", id="Teams"),
        Tab("Log", id="Log")
    ]
    
    COLUMNS = [
        "Team 👾",
        "Host 📡",
        "Flags 🚩",
        "Last status 📊",
        "Last attack 🕰️",
        "Time to exploit ⏱️",
        "Executing ⚠️"
    ]

    def get_team_row(self, team:dict):
        team_id = team.get("id", None)
        name = team.get("name", None)
        short_name = team.get("short_name", None)
        host = team.get("host", None)
        team_info = g.exec.info.teams.get(team_id, TeamInfo())
        
        time_delta = last_execution_time = last_attack_status = None
        executing = False
        if team_info.last:
            time_delta = str(dt.now(datetime.timezone.utc) - team_info.last.end_time).split(".")[0]
            last_execution_time = str(team_info.last.end_time - team_info.last.start_time).split(".")[0]
            last_attack_status = team_info.last.status
            executing = team_info.executing

        match last_attack_status:
            case AttackExecutionStatus.crashed:
                last_attack_status = "⚠️ ☠️ "
            case AttackExecutionStatus.done:
                last_attack_status = " ✅ 🚩"
            case AttackExecutionStatus.noflags:
                last_attack_status = " ❌ 🚩"
            case _:
                last_attack_status = "❓"
        return [
            f"{team_id}: {short_name if short_name else name if name else ''}",
            host if host else "",
            team_info.flags if team_info.flags > 0 else "⚠️  0",
            last_attack_status,
            time_delta + " ago" if time_delta else "⚠️   Never",
            last_execution_time if last_execution_time else "",
            "🔥" if executing else "💤"
        ]
    
    def update_data(self):
        try:
            table = self.query_one(DataTable)
            table.rows.clear()
            column_keys = table.add_columns(*[Text(text="\n\n"+ele, justify="center") for ele in self.COLUMNS])
            while True:
                if g.exec.config.status is None:
                    if g.exec.exit_event.wait(timeout=1):
                        return
                    continue
                
                info = g.exec.info
                submitter_flag_queue = info.submitter_flags_in_queue if info.submitter_flags_in_queue is not None else "❓"
                submitter_status = "🟢" if info.submitter_status else "[bold red]❌ ( Can't submit flags )[/]" if info.submitter_status is not None else "❓"
                if info.config_update is None:
                    config_updater = "🟢" if g.exec.config.status.get("status", None) == "running" else "[bold red]⚠️  Server is not in running mode![/]"
                else:
                    config_updater = "🟢" if info.config_update else "[bold red]❌ (Check server is alive)[/]" if info.config_update is not None else "❓"
                this_time = dt.now(datetime.timezone.utc)
                delta_next_attack = str(info.next_attack_at - this_time).split(".")[0]+" s" if info.next_attack_at and info.next_attack_at > this_time else "❓"
                status_text = self.query_one("#status_text", Label)
                messages = deepcopy(g.exec.config.status.get("messages", []))
                messages = ", ".join([f"[bold red]{ele['level']}[/]: {escape(ele['title'])}" for ele in messages])
                status_text.update(
                    f"[yellow]Exploit [bold]{escape(g.exploit_config.name)}[/] is running.. [/]\t\t\t"
                    f"[bold]{messages}[/]\n"
                    f"Submitter status: [bold green]{submitter_status}[/] (queued: {submitter_flag_queue})\t"
                    f"Exploit timeout: [bold yellow]{info.runtime_timeout if info.runtime_timeout else 'Unknown'} s[/]\t\t\t"
                    f"Tick Duration: [bold green]{g.exec.tick_duration if g.exec.tick_duration else 'Unknown'} s[/]\n"
                    f"Server connection: [bold]{config_updater}[/]\t\t\t"
                    f"Next Attacks: [bold green]{delta_next_attack}[/]\t\t\t"
                    f"Flag Format: [bold green]{escape(g.exec.config.status.get('config', {}).get('FLAG_REGEX', 'Unknown'))}[/]\n"
                    f"System Memory: [bold green]{mem_usage()}%[/]\t\t\t"
                    f"System CPU: [bold green]{psutil.cpu_percent()}%[/]\t\t\t"
                    f"Running worker: [bold green]{info.running_workers} (max: {g.exec.pool_size})[/]"
                )
                
                used_keys = set()
                teams = deepcopy(g.exec.config.status.get("teams", []))
                for team in teams:
                    cols = [Text("\n"+str(cell), justify=("center" if i not in (0,1) else "default")) for i, cell in enumerate(self.get_team_row(team))]
                    team_key = f"team-{team['id']}"
                    used_keys.add(team_key)
                    try:
                        [table.update_cell(row_key=team_key, column_key=column_keys[i], value=cols[i]) for i in range(len(column_keys))]
                    except CellDoesNotExist:
                        table.add_row(*cols, height=3, key=team_key)
                for key in table.rows.keys():
                    if key.value not in used_keys:
                        table.remove_row(row_key=key.value)
                if g.exec.exit_event.wait(timeout=1):
                    return
        except Exception as e:
            g.exec.print_queue.put(f"[bold red]Error on update_data: {e}[/]")
            g.exec.print_queue.put(traceback.format_exc())
    
    def update_log(self):
        logger = self.query_one("#log", RichLog)
        while True:
            if g.exec.exit_event.is_set():
                return
            log = g.exec.print_queue.get()
            if isinstance(log, str):
                logger.write(escape(log), scroll_end=False)
            else:
                logger.write(log, scroll_end=False)
    
    def exit_listener(self):
        if g.exec.exit_event.wait():
            stop_screen()
            self.exit(0)
    
    def on_ready(self) -> None:
        """Called when the DOM is ready."""
        self.run_worker(self.update_data, thread=True)
        self.run_worker(self.update_log, thread=True)
        self.run_worker(self.exit_listener, thread=True)

    def compose(self) -> ComposeResult:
        yield Header(self.title)
        yield Label(id="status_text", classes="full-width")
        yield Tabs(*self.TABS, id="tabs")
        yield DataTable(id="teams", classes="tab tab-Teams hidden", cell_padding=3, header_height=5, cursor_type="none" )
        yield RichLog(highlight=True, id="log", classes="tab tab-Log hidden", wrap=True, auto_scroll=True, max_lines=5000)
        yield Footer()    
        
    def show_tab(self, tab_name:str):
        self.query(".tab").add_class("hidden")
        self.query(f".tab-{tab_name}").remove_class("hidden")

    def action_show_tab(self, tab_name:str):
        self.query_one("#tabs", Tabs)._activate_tab(self.query_one(f"#{tab_name}", Tab))

    def on_tabs_tab_activated(self, event: Tabs.TabActivated) -> None:
        """Handle TabActivated message sent by Tabs."""
        self.show_tab(event.tab.label_text)

    def action_cancel(self):
        with self.suspend(): # Needed to avoid the app to hang, and terminal to be unusable
            self.exit(0)
            stop_screen()
    
