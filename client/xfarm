#!/usr/bin/env python3

import typer
from rich import print
from rich.markup import escape
from rich.console import Console

from enum import Enum
from exploitfarm.utils.reqs import get_url
from exploitfarm.utils.cmd.config import InitialConfiguration, inital_config_setup, ClientConfig
from exploitfarm.utils.cmd.login import login_required, try_authenticate
from exploitfarm.utils.cmd.exploitinit import ExploitInit
from exploitfarm.utils.config import ExploitConfig, check_exploit_config_exists
import getpass, re, os, orjson
from pydantic import NonNegativeInt
from typing import Optional
from uuid import UUID
from exploitfarm.model import Language
from exploitfarm.utils.config import EXPLOIT_CONFIG_REGEX

app = typer.Typer(
    no_args_is_help=True,
    add_completion=False
)
console = Console()

class g:
    interactive = True
    config: ClientConfig = ClientConfig.read()

def initial_setup(login=True):
    inital_config_setup(g.config, interactive=g.interactive)
    if login:
        login_required(g.config, interactive=g.interactive)

@app.command(help="Configure the client settings")
def config(
    address: str = typer.Option(None, help="The address of the server"),
    port: int = typer.Option(None, help="The port of the server"),
    nickname: str = typer.Option(None, help="The nickname of this client"),
    https: bool = typer.Option(False, help="Use HTTPS for the connection"),
    skip_connection_test: bool = typer.Option(False, help="Skip the connection test"),
):
    if g.interactive:
        init_config = InitialConfiguration(g.config)
        if init_config.run() == 0:
            print("[bold green]Configuration saved![/]")
        else:
            print("[bold red]Configuration cancelled[/]")
    else:
        if address:
            g.config.server.address = address
        if port:
            g.config.server.port = port
        if nickname:
            g.config.client_name = nickname
        if https:
            g.config.server.https = https
        if skip_connection_test:
            g.config.ignore_connection_failed = skip_connection_test
        elif not g.config.test_server():
            print(f"[bold red]Connection test failed to {escape(get_url('//', g.config))}[/]")
            return
        g.config.write()
        print("[bold green]Config updated[/]")

@app.command(help="Reset the client settings")
def reset():
    print("[bold yellow]Are you sure you want to reset configs?\n[bold red]This operation may break some exploits running on the client.", end="")
    delete = typer.confirm("")
    if delete:
        ClientConfig().write()
        print("[bold green]Client resetted successful[/]")
    else:
        print("[bold]Reset cancelled[/]")

@app.command(help="Start the exploit")
def start(
    path: str = typer.Argument("./", help="The path of the exploit"),
    pool_size:NonNegativeInt = typer.Option(50, help="The number of workers to start"),
    test: Optional[str] = typer.Option(None, help="Test the exploit"),
):
    from exploitfarm.xploit import start_xploit
    initial_setup()
    if g.config.status:
        print("[bold red]Can't connect to the server! Configure with 'xfarm config'[/]")
        return
    if not test:
        start_xploit(g.config, pool_size, path)
    else:
        raise NotImplementedError("Test is not implemented yet")

@app.command(help="Login to the server")
def login(
    password: str = typer.Option(None, help="The password of the user"),
    stdin: bool = typer.Option(False, help="Read the password from stdin"),
):
    initial_setup(login=False)
    
    if g.config.status["status"] == "setup":
        print("[bold red]Please configure the server first[/]")
        return
    if g.config.status["loggined"] and not g.config.status["config"]["AUTHENTICATION_REQUIRED"]:
        print("[bold green]Authentication is not required[/]")
        return
    if g.config.status["loggined"]:
        print("[bold green]Already logged in![/]")
        return
    
    if stdin or (not password and not g.interactive):
        if g.interactive:
            password = getpass.getpass("Password: ")
        else:
            password = input("Password: ")
        status, error = try_authenticate(password, g.config)
        if status:
            print("[bold green]Logged in![/]")
        else:
            print(f"[bold red]Error: {escape(error)}[/]")
        return

    if password:
        status, error = try_authenticate(password, g.config)
        if status:
            print("[bold green]Logged in![/]")
        else:
            print(f"[bold red]Error: {escape(error)}[/]")
        return

    login_required(g.config, interactive=g.interactive)

@app.command(help="Logout from the server")
def logout():
    g.config.server.auth_key = None
    g.config.write()
    print("[bold red]Logged out[/]")

@app.command(help="Test a submitter")
def submitter_test(
    path: str = typer.Argument(help="Submitter python script"),
    kwargs: str = typer.Option("{}", help="Submitter key-words args (json)"),
    output: str = typer.Argument(help="Text containing flags according to server REGEX")
):
    initial_setup()
    try:
        kwargs = orjson.loads(kwargs)
    except Exception as e:
        print(f"[bold red]Invalid kwargs json: {e}")
        return
    
    try:
        with open(path, "rt") as f:
            submitter_code = f.read()
    except Exception as e:
        print(f"[bold red]File {escape(path)} not found: {e}")
        return
    
    if not output:
        print("[bold red]Output can't be empty")
    
    flags = [output]
    if g.config.status["config"]["FLAG_REGEX"]:
        flags = re.findall(g.config.status["config"]["FLAG_REGEX"], output)
    
    if len(flags) == 0:
        print(f"[bold red]No flags extracted from output! REGEX: {escape(g.config.status['config']['FLAG_REGEX'])}")
        return
    
    try:
        submitter_id:int = g.config.reqs.new_submitter({
            "name": "TEST_SUBMITTER (Will be deleted soon)",
            "kargs": kwargs,
            "code": submitter_code
        })["id"]
        print("[bold yellow]----- TEST RESULTS -----")
        print("[bold yellow]Flags to submit:[/]", flags)
        print("[bold yellow]Output:[/]")
        print(g.config.reqs.test_submitter(submitter_id, flags))
        print("[bold yellow]----- TEST RESULTS -----")
    finally:
        g.config.reqs.delete_submitter(submitter_id)

class StatusWhat(Enum):
    status = "status"
    submiters = "submitters"
    services = "services"
    exploits = "exploits"
    flags = "flags"
    teams = "teams"
    clients = "clients"

@app.command(help="Get status of the server")
def status(
    what:StatusWhat = typer.Argument(StatusWhat.status.value, help="Server informations type")
):
    initial_setup()
    match what:
        case StatusWhat.status:
            print(g.config.status)
        case StatusWhat.submiters:
            print(g.config.reqs.submitters())
        case StatusWhat.services:
            print(g.config.reqs.services())
        case StatusWhat.exploits:
            print(g.config.reqs.exploits())
        case StatusWhat.flags:
            print(g.config.reqs.flags())
        case StatusWhat.teams:
            print(g.config.reqs.teams())
        case StatusWhat.clients:
            print(g.config.reqs.clients())

@app.command(help="Initiate a new exploit configuration")
def init(
    name: Optional[str] = typer.Option(None, help="The name of the exploit"),
    service: Optional[UUID] = typer.Option(None, help="The service of the exploit"),
    language: Optional[Language] = typer.Option(Language.python.value, help="The language of the exploit"),
):
    initial_setup()
    if g.interactive:
        init_config = ExploitInit(g.config)
        if init_config.run() == 0:
            print("[bold green]Exploit configuration created![/]")
        else:
            print("[bold red]Exploit configuration cancelled[/]")
    else:
        
        if not name or not re.match(EXPLOIT_CONFIG_REGEX, name):
            print(f"[bold red]Please provide a valid name for the exploit (regex: {escape(EXPLOIT_CONFIG_REGEX)})[/]")
            return
        
        try:
            if not service in [UUID(ele["id"]) for ele in g.config.status["services"]]:
                raise ValueError("Service not found")
        except Exception:
            print("[bold red]Service id not found[/]")
            return
        
        if not language:
            print("[bold red]Language not found[/]")
            return
        
        if name and service and language:
            if check_exploit_config_exists(name):
                print(f"[bold red]Exploit '{escape(name)}' already exists!")
                return
            expl_conf = ExploitConfig.new(name, language, service)
            expl_conf.write(name)
            expl_conf.publish_exploit(g.config)
            print("[bold green]Exploit configuration created![/]")
        else:
            print("[bold red]Please provide all the required arguments[/]")

@app.callback()
def main(interactive: bool = typer.Option(True, help="Interactive configuration mode", envvar="XFARM_INTERACTIVE")):
    g.interactive = interactive

if __name__ == "__main__":
    app()
