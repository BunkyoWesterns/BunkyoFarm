from models.exploit import *
from models.response import *
from models.enums import *
from models.config import *
from db import Exploit, AttackExecution, Flag
from utils import *
from typing import List
from fastapi import APIRouter, HTTPException, UploadFile, File, Form
from typing import Dict
from env import EXPLOIT_SOURCES_DIR
import tarfile, tempfile
from fastapi.responses import FileResponse
from exploitfarm.utils.config import ExploitConfig, check_exploit_config_exists
from exploitfarm.utils import calc_hash


router = APIRouter(prefix="/exploits", tags=["Exploits"])

@router.get("", response_model=List[ExploitDTO])
async def exploits_get():
    config = await Configuration.get_from_db()
    async def elaborate_dto(ele: Exploit) -> ExploitDTO:
        last_attack_execution = await AttackExecution.objects.filter(exploit=ele).order_by(AttackExecution.received_at.desc()).limit(1).get_or_none()
        if last_attack_execution and config.SETUP_STATUS != SetupStatus.SETUP:
            max_timeout = 5 #Base timeout
            match config.ATTACK_MODE:
                case AttackMode.WAIT_FOR_TIME_TICK:
                    max_timeout += config.ATTACK_TIME_TICK_DELAY + config.TICK_DURATION
                case AttackMode.TICK_DELAY:
                    max_timeout += config.TICK_DURATION
                case AttackMode.LOOP_DELAY:
                    max_timeout += max(config.LOOP_ATTACK_DELAY, config.TICK_DURATION)
            ele.status = ExploitStatus.disabled if (datetime_now() - last_attack_execution.received_at).total_seconds() > max_timeout else ExploitStatus.active
        return ExploitDTO(
            **ele.model_dump(mode="json"),
            last_execution_by = last_attack_execution.executed_by if last_attack_execution else None,
            last_update = last_attack_execution.received_at if last_attack_execution else ele.created_at
        )
    return await asyncio.gather(*[elaborate_dto(ele) for ele in await Exploit.objects.all()])

@router.post("", response_model=MessageResponse[ExploitDTO])
async def exploit_new_or_edit(data: ExploitAddForm):
    exploit = await Exploit.objects.get_or_none(id=data.id)
    if exploit:
        data.created_by = exploit.created_by # Can't change the creator
        exploit = await exploit.update(**json_like(data))
        return { "message": "Exploit updated successfully", "response": exploit }
    exploit = await Exploit(**json_like(data)).save()
    
    return { "message": "Exploit created successfully", "response": exploit }

@router.delete("/{exploit_id}", response_model=MessageResponse[ExploitDTO])
async def exploit_delete_hashed_or_uuid(exploit_id: ExploitID):
    exploit = await Exploit.objects.get_or_none(id=exploit_id)
    if not exploit:
        raise HTTPException(404, "Exploit not found")
    sources = await ExploitSource.objects.filter(exploit=exploit).all()
    await exploit.delete()
    # Delete all sources from the filesystem
    for source in sources:
        file_path = os.path.join(EXPLOIT_SOURCES_DIR, f"{source.hash}.tar.gz")
        if os.path.exists(file_path):
            os.remove(file_path)
    return { "message": "Exploit deleted successfully", "response": exploit }


@router.put("/{exploit_id}", response_model=MessageResponse[ExploitDTO])
async def exploit_edit(exploit_id: ExploitID, data: ExploitEditForm):
    exploit = await Exploit.objects.get_or_none(id=exploit_id)
    if not exploit:
        raise HTTPException(404, "Exploit not found")
    data.created_by = exploit.created_by # Can't change the creator
    exploit = await exploit.update(**json_like(data))
    return { "message": "Exploit updated successfully", "response": exploit }

@router.post("/{exploit_id}/submit", response_model=MessageResponse[Dict[str, int]])
async def exploit_submit(exploit_id: ExploitID, data: List[ExploitSubmitForm]):
    config = await Configuration.get_from_db()
    
    exploit = await Exploit.objects.get_or_none(id=exploit_id)
    if not exploit:
        raise HTTPException(404, "Exploit not found")
    
    async def attack_exec_commit(parsed_data: Dict[str, str]) -> int:
        flags = extract_values_by_regex(config.FLAG_REGEX, parsed_data["flags"])
        del parsed_data["flags"]
        attack_execution = await AttackExecution(exploit=exploit, **parsed_data).save()
        await bulk_insert([Flag(flag=flag, attack=attack_execution) for flag in flags], postfix="ON CONFLICT (flag) DO NOTHING")
        flags = await Flag.objects.filter(attack=attack_execution).all()
        if len(flags) == 0 and attack_execution.status == AttackExecutionStatus.done.value:
            attack_execution.status = AttackExecutionStatus.noflags.value
            await attack_execution.update()
        return len(flags) 
 
    results = await asyncio.gather(*[attack_exec_commit(data) for data in [json_like(ele) for ele in data]])
    
    return { "message": "Attacks results submitted successfully", "response": { "flags": sum(results) } }

@router.post("/submit", response_model=MessageResponse[Dict[str, int]])
async def exploit_submit(data: ManualSubmitForm):
    config = await Configuration.get_from_db()
    
    flags = (data.flags if data.flags else [])
    flags.append(data.output if data.output else "")
    flags = extract_values_by_regex(config.FLAG_REGEX, flags)
    
    status = AttackExecutionStatus.done.value if len(flags) > 0 else AttackExecutionStatus.noflags.value
    attack_execution = await AttackExecution(executed_by=MANUAL_CLIENT_ID, status=status).save()
    
    flags = [Flag(flag=flag, attack=attack_execution) for flag in flags]
    await bulk_insert(flags, postfix="ON CONFLICT (flag) DO NOTHING")
    
    return { "message": "Attack results submitted successfully", "response": { "flags": len(flags) } }

@router.post("/source", response_model=MessageResponse[ExploitSourceID|None])
async def new_exploit_source(
    file: Annotated[UploadFile, File()],
    message: Annotated[str|None, Form()],
    os_type: Annotated[str|None, Form()],
    distro: Annotated[str|None, Form()],
    arch: Annotated[str|None, Form()],
    pushed_by: Annotated[UnHashedClientID|None, Form()]
):  
    with tempfile.TemporaryDirectory(ignore_cleanup_errors=True) as temp_dir:
        with tempfile.NamedTemporaryFile("w+b") as temp_file:
            try:
                while rBytes := await file.read(1024):
                    temp_file.write(rBytes)
                temp_file.seek(0)
                tfile = tarfile.open(fileobj=temp_file, mode="r:gz")
                tfile.extractall(path=temp_dir)
            except Exception as e:
                raise MessageResponseInvalidError("Invalid tar.gz file", str(e))
            if not check_exploit_config_exists(temp_dir):
                raise MessageResponseInvalidError("config.toml not found in the tar.gz file")
            try:
                expl_config = ExploitConfig.read(temp_dir)
            except Exception as e:
                raise MessageResponseInvalidError("Invalid config.toml file", str(e))
            exploit = await Exploit.objects.get_or_none(id=expl_config.uuid)
            if not exploit:
                raise HTTPException(404, "Exploit not found")
            try:
                hash_id = calc_hash(temp_dir)
            except Exception as e:
                raise MessageResponseInvalidError("Cannot calculate hash of exploit source", str(e))
            final_file_path = os.path.join(EXPLOIT_SOURCES_DIR, f"{hash_id}.tar.gz")
            if not os.path.exists(final_file_path):
                os.rename(temp_file.name, final_file_path)
    
    expl_src = await ExploitSource(
        hash=hash_id,
        message=message,
        os_type=os_type,
        distro=distro,
        arch=arch,
        exploit=exploit,
        pushed_by=pushed_by
    ).save()
    
    return { "message": "Exploit Source pushed correctly", "response": expl_src.id }

@router.get("/{exploit_id}/source", response_model=List[ExploitSourceDTO])
async def exploit_source_list(exploit_id: ExploitID):
    exploit = await Exploit.objects.get_or_none(id=exploit_id)
    if not exploit:
        raise HTTPException(404, "Exploit not found")
    return await ExploitSource.objects.filter(exploit=exploit).order_by(ExploitSource.pushed_at.desc()).all()

@router.get("/source/{source_hash}/download", response_class=FileResponse)
async def download_exploit_source(source_hash: str):
    file_path = os.path.join(EXPLOIT_SOURCES_DIR, f"{source_hash}.tar.gz")
    if not os.path.exists(file_path):
        raise HTTPException(404, "Source file not found")
    return FileResponse(file_path)

@router.delete("/source/{source_id}", response_model=MessageResponse[ExploitSourceID])
async def delete_exploit_source(source_id: ExploitSourceID):
    source_metadata = await ExploitSource.objects.get_or_none(id=source_id)
    if source_metadata is None:
        raise HTTPException(404, "Source file not found")
    
    #Other sources can share the same exploit source tar.gz file
    all_exploit_sources = await ExploitSource.objects.filter(exploit=source_metadata.exploit).all()
    can_delete_source_file = len(list(filter(lambda x: x.hash == source_metadata.hash, all_exploit_sources))) <= 1
    
    file_path = os.path.join(EXPLOIT_SOURCES_DIR, f"{source_metadata.hash}.tar.gz")
    
    if os.path.exists(file_path) and can_delete_source_file:
        os.remove(file_path)
    if not source_metadata is None:
        await source_metadata.delete()
    
    return { "message": "Source deleted successfully", "response": source_id }

@router.put("/source/{source_id}", response_model=MessageResponse[ExploitSourceDTO|None])
async def edit_exploit_source(source_id: ExploitSourceID, data: ExploitSourcePushForm):
    source_metadata = await ExploitSource.objects.get_or_none(id=source_id)
    if source_metadata is None:
        raise HTTPException(404, "Source file not found")
    source_metadata = await source_metadata.update(**json_like(data))
    return { "message": "Exploit source updated successfully", "response": source_metadata }
