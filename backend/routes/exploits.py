import os
import tarfile
import tempfile
import shutil
import pickle
import asyncio
from models.exploit import ExploitDTO, ExploitAddForm, ExploitEditForm, ManualSubmitForm
from models.exploit import ExploitSourcePushForm, ExploitSourceDTO, ExploitSubmitForm
from models.response import MessageResponse, MessageResponseInvalidError
from models.enums import ExploitStatus, AttackExecutionStatus
from models.config import Configuration
from utils import json_like, extract_values_by_regex, datetime_now
from typing import List, Annotated, Tuple
from fastapi import APIRouter, HTTPException, UploadFile, File, Form
from typing import Dict
from env import EXPLOIT_SOURCES_DIR
from fastapi.responses import FileResponse
from exploitfarm.utils.config import ExploitConfig, check_exploit_config_exists
from exploitfarm.utils import calc_hash
from db import Exploit, DBSession, AttackExecution, sqla, ExploitSource, Flag, MANUAL_CLIENT_ID, Service, redis_channels, redis_conn
from utils.query import get_exploits_with_latest_attack, get_exploit_status
from db import ExploitID, ExploitSourceID, UnHashedClientID

router = APIRouter(prefix="/exploits", tags=["Exploits"])

@router.get("", response_model=List[ExploitDTO])
async def exploits_get(db: DBSession):
    config = await Configuration.get_from_db()
    exploits = await get_exploits_with_latest_attack(db)
    
    async def result(result: sqla.Row[Tuple[Exploit, AttackExecution]]):
        exploit, latest_attack = result.tuple()        
        return ExploitDTO(
            **json_like(exploit, mode="python", unset=True),
            last_execution_by = latest_attack.executed_by_id if latest_attack else None,
            last_update = latest_attack.received_at if latest_attack else exploit.created_at,
            last_execution_group_by = latest_attack.executed_by_group_id if latest_attack else None,
            last_source = latest_attack.exploit_source_id if latest_attack else None,
            status = await get_exploit_status(config, latest_attack)
        )
    return await asyncio.gather(*[result(ele) for ele in exploits])

@router.post("", response_model=MessageResponse[ExploitDTO])
async def exploit_new_or_edit(data: ExploitAddForm, db: DBSession):
    
    service = data.service
    service = (await db.scalars(
        sqla.select(Service).where(Service.id == service)
    )).one_or_none()
    if not service:
        raise HTTPException(400, "Service not found")
    
    exploit = (await db.scalars(
        sqla.insert(Exploit)
            .values(data.db_data())
            .on_conflict_do_update(
                index_elements=[Exploit.id],
                set_={ k: v for k, v in data.db_data().items() if k != "created_by" }
        ).returning(Exploit)
    )).one()
    await db.commit()
    await redis_conn.publish(redis_channels.exploit, "update")
    return { "message": "Exploit created/updated successfully", "response": json_like(exploit, unset=True) }

@router.delete("/{exploit_id}", response_model=MessageResponse[ExploitDTO])
async def exploit_delete(exploit_id: ExploitID, db: DBSession):
    
    sources = (await db.scalars(
        sqla.delete(ExploitSource)
        .where(ExploitSource.exploit_id == exploit_id)
        .returning(ExploitSource)
    )).all()
    
    exploit = (await db.scalars(sqla.delete(Exploit).where(Exploit.id == exploit_id).returning(Exploit))).one_or_none()
    if not exploit:
        raise HTTPException(404, "Exploit not found")
    
    for source in sources:
        file_path = os.path.join(EXPLOIT_SOURCES_DIR, f"{source.hash}.tar.gz")
        if os.path.exists(file_path):
            os.remove(file_path)
    await db.commit()
    await redis_conn.publish(redis_channels.exploit, "update")
    return { "message": "Exploit deleted successfully", "response": json_like(exploit, unset=True) }


@router.put("/{exploit_id}", response_model=MessageResponse[ExploitDTO])
async def exploit_edit(exploit_id: ExploitID, data: ExploitEditForm, db: DBSession):
    if data.service:
        service = data.service
        service = (await db.scalars(
            sqla.select(Service).where(Service.id == service)
        )).one_or_none()
        if not service:
            raise HTTPException(400, "Service not found")
    
    result = (await db.scalars(
        sqla.update(Exploit).where(Exploit.id == exploit_id)
        .values(data.db_data())
        .returning(Exploit)
    )).one_or_none()
    
    if not result:
        raise HTTPException(404, "Exploit not found")
    await db.commit()
    await redis_conn.publish(redis_channels.exploit, "update")
    return { "message": "Exploit updated successfully", "response": json_like(result, unset=True) }

@router.post("/{exploit_id}/submit", response_model=MessageResponse[Dict[str, int]])
async def exploit_submit(exploit_id: ExploitID, data: List[ExploitSubmitForm], db: DBSession):
    config = await Configuration.get_from_db()
    stmt = sqla.select(Exploit).where(Exploit.id == exploit_id)
    exploit = (await db.scalars(stmt)).one_or_none()
    if not exploit:
        raise HTTPException(404, "Exploit not found")
    
    # Check if the exploit was disabled, trigger an update
    trigger_exploit_update = False
    stmt = (sqla.select(AttackExecution)
        .where(AttackExecution.exploit_id == exploit_id)
        .order_by(AttackExecution.received_at.desc())
        .limit(1)
    )
    last_attack = (await db.scalars(stmt)).one_or_none()
    current_exploit_status = await get_exploit_status(config, last_attack)
    if current_exploit_status == ExploitStatus.disabled:
        trigger_exploit_update = True
    
    async def attack_exec_commit(parsed_data: Dict[str, str]) -> int:
        flags = extract_values_by_regex(config.FLAG_REGEX, parsed_data["flags"])
        del parsed_data["flags"]
        parsed_data["exploit_id"] = exploit.id
        attack_execution = (await db.scalars(
            sqla.insert(AttackExecution)
                .values(parsed_data)
                .returning(AttackExecution)
        )).one()
        db.add(attack_execution)
        if len(flags) > 0:
            flags = (await db.scalars(
                sqla.insert(Flag)
                    .values([{"flag": flag, "attack_id": attack_execution.id} for flag in flags])
                    .on_conflict_do_nothing(index_elements=[Flag.flag])
                    .returning(Flag)
            )).all()
        
        if len(flags) == 0 and attack_execution.status == AttackExecutionStatus.done:
            attack_execution.status = AttackExecutionStatus.noflags
        return len(flags)
 
    results = await asyncio.gather(*[attack_exec_commit(data) for data in [ele.db_data() for ele in data]])
    await db.commit()
    if trigger_exploit_update:
        await redis_conn.publish(redis_channels.exploit, "update")
    await redis_conn.publish(redis_channels.attack_execution, "update")
    return { "message": "Attacks results submitted successfully", "response": { "flags": sum(results) } }

@router.post("/{exploit_id}/stopped", response_model=MessageResponse)
async def exploit_stopped(exploit_id: ExploitID, db: DBSession):
    stmt = sqla.select(Exploit).where(Exploit.id == exploit_id)
    expl = (await db.scalars(stmt)).one_or_none()
    if not expl:
        raise HTTPException(404, "Exploit not found")
    await redis_conn.set(f"last_exploit_{exploit_id}_stopped", pickle.dumps(datetime_now()))
    await redis_conn.publish(redis_channels.exploit, "update")
    return { "message": f"Exploit {exploit_id} stopped" }

@router.post("/submit", response_model=MessageResponse[Dict[str, int]])
async def exploit_submit_manual(data: ManualSubmitForm, db: DBSession):
    config = await Configuration.get_from_db()
    
    flags = (data.flags if data.flags else [])
    flags.append(data.output if data.output else "")
    flags = extract_values_by_regex(config.FLAG_REGEX, flags)
    
    status = AttackExecutionStatus.done if len(flags) > 0 else AttackExecutionStatus.noflags
    attack_execution = (await db.scalars(
        sqla.insert(AttackExecution)
            .values(executed_by_id=MANUAL_CLIENT_ID, status=status)
            .returning(AttackExecution)
    )).one()
    if len(flags) > 0:
        flags = (await db.scalars(
            sqla.insert(Flag)
                .values([{"flag": flag, "attack_id": attack_execution.id} for flag in flags])
                .on_conflict_do_nothing(index_elements=[Flag.flag])
                .returning(Flag)
        )).all()

    await db.commit()
    await redis_conn.publish(redis_channels.attack_execution, "update")
    return { "message": "Attack results submitted successfully", "response": { "flags": len(flags) } }

@router.post("/source", response_model=MessageResponse[ExploitSourceID|None])
async def new_exploit_source(
    file: Annotated[UploadFile, File()],
    message: Annotated[str|None, Form()],
    os_type: Annotated[str|None, Form()],
    distro: Annotated[str|None, Form()],
    arch: Annotated[str|None, Form()],
    pushed_by: Annotated[UnHashedClientID|None, Form()],
    db: DBSession
):  
    with tempfile.TemporaryDirectory(ignore_cleanup_errors=True) as temp_dir:
        with tempfile.NamedTemporaryFile("w+b") as temp_file:
            try:
                while rBytes := await file.read(1024):
                    temp_file.write(rBytes)
                temp_file.seek(0)
                tfile = tarfile.open(fileobj=temp_file, mode="r:gz")
                tfile.extractall(path=temp_dir)
            except Exception as e:
                raise MessageResponseInvalidError("Invalid tar.gz file", str(e))
            if not check_exploit_config_exists(temp_dir):
                raise MessageResponseInvalidError("config.toml not found in the tar.gz file")
            try:
                expl_config = ExploitConfig.read(temp_dir)
            except Exception as e:
                raise MessageResponseInvalidError("Invalid config.toml file", str(e))
            
            stmt = sqla.select(Exploit).where(Exploit.id == expl_config.uuid)
            exploit = (await db.scalars(stmt)).one_or_none()
            if not exploit:
                raise HTTPException(404, "Exploit not found")
            try:
                hash_id = calc_hash(temp_dir)
            except Exception as e:
                raise MessageResponseInvalidError("Cannot calculate hash of exploit source", str(e))
            
            expl_src = (await db.scalars(
                sqla.insert(ExploitSource)
                    .values(
                        hash=hash_id,
                        message=message,
                        os_type=os_type,
                        distro=distro,
                        arch=arch,
                        exploit_id=exploit.id,
                        pushed_by_id=pushed_by
                    ).returning(ExploitSource)
            )).one()
            
            final_file_path = os.path.join(EXPLOIT_SOURCES_DIR, f"{hash_id}.tar.gz")
            if not os.path.exists(final_file_path):
                shutil.move(temp_file.name, final_file_path)
    
    await db.commit()
    await redis_conn.publish(redis_channels.exploit_source, "update")
    return { "message": "Exploit Source pushed correctly", "response": expl_src.id }

@router.get("/{exploit_id}/source", response_model=List[ExploitSourceDTO])
async def exploit_source_list(exploit_id: ExploitID, db: DBSession):
    stmt = sqla.select(Exploit).where(Exploit.id == exploit_id)
    exploit = (await db.scalars(stmt)).one_or_none()
    if not exploit:
        raise HTTPException(404, "Exploit not found")
    stmt = (
        sqla.select(ExploitSource)
            .where(ExploitSource.exploit_id == exploit.id)
            .order_by(ExploitSource.pushed_at.desc())
    )
    return json_like((await db.scalars(stmt)).all(), unset=True)

@router.get("/source/{source_hash}/download", response_class=FileResponse)
async def download_exploit_source(source_hash: str):
    file_path = os.path.join(EXPLOIT_SOURCES_DIR, f"{source_hash}.tar.gz")
    if not os.path.exists(file_path):
        raise HTTPException(404, "Source file not found")
    return FileResponse(file_path, filename=f"source_{source_hash}.tar.gz")

@router.delete("/source/{source_id}", response_model=MessageResponse[ExploitSourceID])
async def delete_exploit_source(source_id: ExploitSourceID, db: DBSession):
    sources_metadata = (await db.scalars(
        sqla.select(ExploitSource).where(ExploitSource.hash == (
            sqla.select(ExploitSource.hash).where(ExploitSource.id == source_id)
        ))
    )).all()
    if len(sources_metadata) == 0:
        raise HTTPException(404, "Source file not found")
    
    can_delete_source_file = len(sources_metadata) <= 1
    file_path = os.path.join(EXPLOIT_SOURCES_DIR, f"{sources_metadata[0].hash}.tar.gz")
    
    if can_delete_source_file and os.path.exists(file_path):
        os.remove(file_path)
    
    for ele in sources_metadata:
        if ele.id == source_id:
            await db.delete(ele)
            break
    
    await db.commit()
    await redis_conn.publish(redis_channels.exploit_source, "update")
    return { "message": "Source deleted successfully", "response": source_id }

@router.put("/source/{source_id}", response_model=MessageResponse[ExploitSourceDTO|None])
async def edit_exploit_source(source_id: ExploitSourceID, data: ExploitSourcePushForm, db: DBSession):
    source_metadata = (await db.scalars(
        sqla.update(ExploitSource).where(ExploitSource.id == source_id)
        .values(**json_like(data)).returning(ExploitSource)
    )).one_or_none()
    if source_metadata is None:
        raise HTTPException(404, "Source file not found")
    await db.commit()
    await redis_conn.publish(redis_channels.exploit_source, "update")
    return { "message": "Exploit source updated successfully", "response": json_like(source_metadata, unset=True) }
