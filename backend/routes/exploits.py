from models.exploit import *
from models.response import *
from models.enums import *
from models.config import *
from db import Exploit, AttackExecution, Flag
from utils import *
from typing import List
from fastapi import APIRouter, HTTPException
from typing import Dict

router = APIRouter(prefix="/exploits", tags=["Exploits"])

@router.get("", response_model=List[ExploitDTO])
async def exploits_get():
    config = await Configuration.get_from_db()
    async def elaborate_dto(ele: Exploit) -> ExploitDTO:
        last_attack_execution = await AttackExecution.objects.filter(exploit=ele).order_by(AttackExecution.recieved_at.desc()).limit(1).get_or_none()
        if last_attack_execution and config.SETUP_STATUS != SetupStatus.SETUP:
            max_timeout = 5 #Base timeout
            match config.ATTACK_MODE:
                case AttackMode.WAIT_FOR_TIME_TICK:
                    max_timeout += config.ATTACK_TIME_TICK_DELAY + config.TICK_DURATION
                case AttackMode.TICK_DELAY:
                    max_timeout += config.TICK_DURATION
                case AttackMode.LOOP_DELAY:
                    max_timeout += max(config.LOOP_ATTACK_DELAY, config.TICK_DURATION)
            ele.status = ExploitStatus.disabled if (datetime_now() - last_attack_execution.recieved_at).total_seconds() > max_timeout else ExploitStatus.active
        return ExploitDTO(
            **ele.model_dump(mode="json"),
            last_execution_by = last_attack_execution.executed_by if last_attack_execution else None,
            last_update = last_attack_execution.recieved_at if last_attack_execution else ele.created_at
        )
    return await asyncio.gather(*[elaborate_dto(ele) for ele in await Exploit.objects.all()])

@router.post("", response_model=MessageResponse[ExploitDTO])
async def exploit_new_or_edit(data: ExploitAddForm):
    exploit = await Exploit.objects.get_or_none(id=data.id)
    if exploit:
        data.created_by = exploit.created_by # Can't change the creator
        exploit = await exploit.update(**json_like(data))
        return { "message": "Exploit updated successfully", "response": exploit }
    exploit = await Exploit(**json_like(data)).save()
    
    return { "message": "Exploit created successfully", "response": exploit }

@router.delete("/{exploit_id}", response_model=MessageResponse[ExploitDTO])
async def exploit_delete_hashed_or_uuid(exploit_id: ExploitID):
    exploit = await Exploit.objects.get_or_none(id=exploit_id)
    if not exploit:
        raise HTTPException(404, "Exploit not found")
    await exploit.delete()
    return { "message": "Exploit deleted successfully", "response": exploit }


@router.put("/{exploit_id}", response_model=MessageResponse[ExploitDTO])
async def exploit_edit(exploit_id: ExploitID, data: ExploitEditForm):
    exploit = await Exploit.objects.get_or_none(id=exploit_id)
    if not exploit:
        raise HTTPException(404, "Exploit not found")
    data.created_by = exploit.created_by # Can't change the creator
    exploit = await exploit.update(**json_like(data))
    return { "message": "Exploit updated successfully", "response": exploit }

@router.post("/{exploit_id}/submit", response_model=MessageResponse[Dict[str, int]])
async def exploit_submit(exploit_id: ExploitID, data: List[ExploitSubmitForm]):
    config = await Configuration.get_from_db()
    
    exploit = await Exploit.objects.get_or_none(id=exploit_id)
    if not exploit:
        raise HTTPException(404, "Exploit not found")
    
    async def attack_exec_commit(parsed_data: Dict[str, str]) -> int:
        flags = extract_values_by_regex(config.FLAG_REGEX, parsed_data["flags"])
        del parsed_data["flags"]
        attack_execution = await AttackExecution(exploit=exploit, **parsed_data).save()
        await bulk_insert([Flag(flag=flag, attack=attack_execution) for flag in flags], postfix="ON CONFLICT (flag) DO NOTHING")
        flags = await Flag.objects.filter(attack=attack_execution).all()
        if len(flags) == 0 and attack_execution.status == AttackExecutionStatus.done.value:
            attack_execution.status = AttackExecutionStatus.noflags.value
            await attack_execution.update()
        return len(flags) 
 
    results = await asyncio.gather(*[attack_exec_commit(data) for data in [json_like(ele) for ele in data]])
    
    return { "message": "Attacks results submitted successfully", "response": { "flags": sum(results) } }

@router.post("/submit", response_model=MessageResponse[Dict[str, int]])
async def exploit_submit(data: ManualSubmitForm):
    config = await Configuration.get_from_db()
    
    flags = (data.flags if data.flags else [])
    flags.append(data.output if data.output else "")
    flags = extract_values_by_regex(config.FLAG_REGEX, flags)
    
    status = AttackExecutionStatus.done.value if len(flags) > 0 else AttackExecutionStatus.noflags.value
    attack_execution = await AttackExecution(executed_by=MANUAL_CLIENT_ID, status=status).save()
    
    flags = [Flag(flag=flag, attack=attack_execution) for flag in flags]
    await bulk_insert(flags, postfix="ON CONFLICT (flag) DO NOTHING")
    
    return { "message": "Attack results submitted successfully", "response": { "flags": len(flags) } }