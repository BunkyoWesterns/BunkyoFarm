from models.exploit import *
from models.response import *
from models.enums import *
from models.config import *
from utils import *
from typing import List, Annotated
from fastapi import APIRouter, HTTPException, UploadFile, File, Form
from typing import Dict
from env import EXPLOIT_SOURCES_DIR
import tarfile, tempfile, shutil, pickle
from fastapi.responses import FileResponse
from exploitfarm.utils.config import ExploitConfig, check_exploit_config_exists
from exploitfarm.utils import calc_hash
from db import Exploit, DBSession, AttackExecution, sqla, ExploitSource, Flag, MANUAL_CLIENT_ID, Service, redis_channels, redis_conn
from sqlalchemy.orm import aliased


router = APIRouter(prefix="/exploits", tags=["Exploits"])

@router.get("", response_model=List[ExploitDTO])
async def exploits_get(db: DBSession):
    config = await Configuration.get_from_db()
    
    attack_exec, attack_exec_2 = aliased(AttackExecution), aliased(AttackExecution)
    
    stmt = (
        sqla.select(Exploit, attack_exec)
        .outerjoin(
            attack_exec,
            attack_exec.id == (
                sqla.select(attack_exec_2.id)
                    .where(attack_exec_2.exploit_id == Exploit.id)
                    .order_by(attack_exec_2.received_at.desc())
                    .limit(1)
            ).correlate(Exploit).scalar_subquery()
        )
    )
    exploits = (await db.execute(stmt)).all()
    
    async def result(result: sqla.Row[Tuple[Exploit, AttackExecution]]):
        exploit, latest_attack = result.tuple()
        exploit_status = ExploitStatus.disabled
        if latest_attack and config.SETUP_STATUS != SetupStatus.SETUP:
            max_timeout = 5 #Base timeout
            match config.ATTACK_MODE:
                case AttackMode.WAIT_FOR_TIME_TICK:
                    max_timeout += config.ATTACK_TIME_TICK_DELAY + config.TICK_DURATION
                case AttackMode.TICK_DELAY:
                    max_timeout += config.TICK_DURATION
                case AttackMode.LOOP_DELAY:
                    max_timeout += max(config.LOOP_ATTACK_DELAY, config.TICK_DURATION)
            exploit_status = ExploitStatus.disabled if (datetime_now() - latest_attack.received_at).total_seconds() > max_timeout else ExploitStatus.active
        
        last_exploit_stop = await redis_conn.get(f"last_exploit_{exploit.id}_stopped")
        if last_exploit_stop:
            last_exploit_stop = pickle.loads(last_exploit_stop)
            if last_exploit_stop > latest_attack.received_at:
                exploit_status = ExploitStatus.disabled
        
        return ExploitDTO(
            **json_like(exploit, mode="python", unset=True),
            last_execution_by = latest_attack.executed_by_id if latest_attack else None,
            last_update = latest_attack.received_at if latest_attack else exploit.created_at,
            last_execution_group_by=latest_attack.executed_by_group_id if latest_attack else None,
            last_source=latest_attack.exploit_source_id if latest_attack else None,
            status=exploit_status
        )
    return await asyncio.gather(*[result(ele) for ele in exploits])

@router.post("", response_model=MessageResponse[ExploitDTO])
async def exploit_new_or_edit(data: ExploitAddForm, db: DBSession):
    
    service = data.service
    service = (await db.scalars(
        sqla.select(Service).where(Service.id == service)
    )).one_or_none()
    if not service:
        raise HTTPException(400, "Service not found")
    
    exploit = (await db.scalars(
        sqla.insert(Exploit)
            .values(data.db_data())
            .on_conflict_do_update(
                index_elements=[Exploit.id],
                set_={ k: v for k, v in data.db_data().items() if k != "created_by" }
        ).returning(Exploit)
    )).one()
    
    await redis_conn.publish(redis_channels.exploit, "update")
    return { "message": "Exploit created/updated successfully", "response": json_like(exploit, unset=True) }

@router.delete("/{exploit_id}", response_model=MessageResponse[ExploitDTO])
async def exploit_delete(exploit_id: ExploitID, db: DBSession):
    
    sources = (await db.scalars(
        sqla.delete(ExploitSource)
        .where(ExploitSource.exploit_id == exploit_id)
        .returning(ExploitSource)
    )).all()
    
    exploit = (await db.scalars(sqla.delete(Exploit).where(Exploit.id == exploit_id).returning(Exploit))).one_or_none()
    if not exploit:
        raise HTTPException(404, "Exploit not found")
    
    for source in sources:
        file_path = os.path.join(EXPLOIT_SOURCES_DIR, f"{source.hash}.tar.gz")
        if os.path.exists(file_path):
            os.remove(file_path)
    
    await redis_conn.publish(redis_channels.exploit, "update")
    return { "message": "Exploit deleted successfully", "response": json_like(exploit, unset=True) }


@router.put("/{exploit_id}", response_model=MessageResponse[ExploitDTO])
async def exploit_edit(exploit_id: ExploitID, data: ExploitEditForm, db: DBSession):
    if data.service:
        service = data.service
        service = (await db.scalars(
            sqla.select(Service).where(Service.id == service)
        )).one_or_none()
        if not service:
            raise HTTPException(400, "Service not found")
    
    result = (await db.scalars(
        sqla.update(Exploit).where(Exploit.id == exploit_id)
        .values(data.db_data())
        .returning(Exploit)
    )).one_or_none()
    
    if not result:
        raise HTTPException(404, "Exploit not found")
    
    await redis_conn.publish(redis_channels.exploit, "update")
    return { "message": "Exploit updated successfully", "response": json_like(result, unset=True) }

@router.post("/{exploit_id}/submit", response_model=MessageResponse[Dict[str, int]])
async def exploit_submit(exploit_id: ExploitID, data: List[ExploitSubmitForm], db: DBSession):
    config = await Configuration.get_from_db()
    stmt = sqla.select(Exploit).where(Exploit.id == exploit_id)
    exploit = (await db.scalars(stmt)).one_or_none()
    if not exploit:
        raise HTTPException(404, "Exploit not found")
    
    async def attack_exec_commit(parsed_data: Dict[str, str]) -> int:
        flags = extract_values_by_regex(config.FLAG_REGEX, parsed_data["flags"])
        del parsed_data["flags"]
        parsed_data["exploit_id"] = exploit.id
        attack_execution = (await db.scalars(
            sqla.insert(AttackExecution)
                .values(parsed_data)
                .returning(AttackExecution)
        )).one()
        db.add(attack_execution)
        if len(flags) > 0:
            flags = (await db.scalars(
                sqla.insert(Flag)
                    .values([{"flag": flag, "attack_id": attack_execution.id} for flag in flags])
                    .on_conflict_do_nothing(index_elements=[Flag.flag])
                    .returning(Flag)
            )).all()
        
        if len(flags) == 0 and attack_execution.status == AttackExecutionStatus.done:
            attack_execution.status = AttackExecutionStatus.noflags
        return len(flags)
 
    results = await asyncio.gather(*[attack_exec_commit(data) for data in [ele.db_data() for ele in data]])
    await redis_conn.publish(redis_channels.exploit, "update")
    await redis_conn.publish(redis_channels.attack_execution, "update")
    return { "message": "Attacks results submitted successfully", "response": { "flags": sum(results) } }

@router.post("/{exploit_id}/stopped", response_model=MessageResponse)
async def exploit_stopped(exploit_id: ExploitID, db: DBSession):
    stmt = sqla.select(Exploit).where(Exploit.id == exploit_id)
    expl = (await db.scalars(stmt)).one_or_none()
    if not expl:
        raise HTTPException(404, "Exploit not found")
    await redis_conn.set(f"last_exploit_{exploit_id}_stopped", pickle.dumps(datetime_now()))
    await redis_conn.publish(redis_channels.exploit, "update")
    return { "message": f"Exploit {exploit_id} stopped" }

@router.post("/submit", response_model=MessageResponse[Dict[str, int]])
async def exploit_submit(data: ManualSubmitForm, db: DBSession):
    config = await Configuration.get_from_db()
    
    flags = (data.flags if data.flags else [])
    flags.append(data.output if data.output else "")
    flags = extract_values_by_regex(config.FLAG_REGEX, flags)
    
    status = AttackExecutionStatus.done if len(flags) > 0 else AttackExecutionStatus.noflags
    attack_execution = (await db.scalars(
        sqla.insert(AttackExecution)
            .values(executed_by_id=MANUAL_CLIENT_ID, status=status)
            .returning(AttackExecution)
    )).one()
    if len(flags) > 0:
        flags = (await db.scalars(
            sqla.insert(Flag)
                .values([{"flag": flag, "attack_id": attack_execution.id} for flag in flags])
                .on_conflict_do_nothing(index_elements=[Flag.flag])
                .returning(Flag)
        )).all()

    await redis_conn.publish(redis_channels.attack_execution, "update")
    return { "message": "Attack results submitted successfully", "response": { "flags": len(flags) } }

@router.post("/source", response_model=MessageResponse[ExploitSourceID|None])
async def new_exploit_source(
    file: Annotated[UploadFile, File()],
    message: Annotated[str|None, Form()],
    os_type: Annotated[str|None, Form()],
    distro: Annotated[str|None, Form()],
    arch: Annotated[str|None, Form()],
    pushed_by: Annotated[UnHashedClientID|None, Form()],
    db: DBSession
):  
    with tempfile.TemporaryDirectory(ignore_cleanup_errors=True) as temp_dir:
        with tempfile.NamedTemporaryFile("w+b") as temp_file:
            try:
                while rBytes := await file.read(1024):
                    temp_file.write(rBytes)
                temp_file.seek(0)
                tfile = tarfile.open(fileobj=temp_file, mode="r:gz")
                tfile.extractall(path=temp_dir)
            except Exception as e:
                raise MessageResponseInvalidError("Invalid tar.gz file", str(e))
            if not check_exploit_config_exists(temp_dir):
                raise MessageResponseInvalidError("config.toml not found in the tar.gz file")
            try:
                expl_config = ExploitConfig.read(temp_dir)
            except Exception as e:
                raise MessageResponseInvalidError("Invalid config.toml file", str(e))
            
            stmt = sqla.select(Exploit).where(Exploit.id == expl_config.uuid)
            exploit = (await db.scalars(stmt)).one_or_none()
            if not exploit:
                raise HTTPException(404, "Exploit not found")
            try:
                hash_id = calc_hash(temp_dir)
            except Exception as e:
                raise MessageResponseInvalidError("Cannot calculate hash of exploit source", str(e))
            
            expl_src = (await db.scalars(
                sqla.insert(ExploitSource)
                    .values(
                        hash=hash_id,
                        message=message,
                        os_type=os_type,
                        distro=distro,
                        arch=arch,
                        exploit_id=exploit.id,
                        pushed_by_id=pushed_by
                    ).returning(ExploitSource)
            )).one()
            
            final_file_path = os.path.join(EXPLOIT_SOURCES_DIR, f"{hash_id}.tar.gz")
            if not os.path.exists(final_file_path):
                shutil.move(temp_file.name, final_file_path)
    await redis_conn.publish(redis_channels.exploit_source, "update")
    return { "message": "Exploit Source pushed correctly", "response": expl_src.id }

@router.get("/{exploit_id}/source", response_model=List[ExploitSourceDTO])
async def exploit_source_list(exploit_id: ExploitID, db: DBSession):
    stmt = sqla.select(Exploit).where(Exploit.id == exploit_id)
    exploit = (await db.scalars(stmt)).one_or_none()
    if not exploit:
        raise HTTPException(404, "Exploit not found")
    stmt = (
        sqla.select(ExploitSource)
            .where(ExploitSource.exploit_id == exploit.id)
            .order_by(ExploitSource.pushed_at.desc())
    )
    return json_like((await db.scalars(stmt)).all(), unset=True)

@router.get("/source/{source_hash}/download", response_class=FileResponse)
async def download_exploit_source(source_hash: str):
    file_path = os.path.join(EXPLOIT_SOURCES_DIR, f"{source_hash}.tar.gz")
    if not os.path.exists(file_path):
        raise HTTPException(404, "Source file not found")
    return FileResponse(file_path, filename=f"source_{source_hash}.tar.gz")

@router.delete("/source/{source_id}", response_model=MessageResponse[ExploitSourceID])
async def delete_exploit_source(source_id: ExploitSourceID, db: DBSession):
    sources_metadata = (await db.scalars(
        sqla.select(ExploitSource).where(ExploitSource.hash == (
            sqla.select(ExploitSource.hash).where(ExploitSource.id == source_id)
        ))
    )).all()
    if len(sources_metadata) == 0:
        raise HTTPException(404, "Source file not found")
    
    can_delete_source_file = len(sources_metadata) <= 1
    file_path = os.path.join(EXPLOIT_SOURCES_DIR, f"{sources_metadata[0].hash}.tar.gz")
    
    if can_delete_source_file and os.path.exists(file_path):
        os.remove(file_path)
    
    for ele in sources_metadata:
        if ele.id == source_id:
            await db.delete(ele)
            break
    await redis_conn.publish(redis_channels.exploit_source, "update")
    return { "message": "Source deleted successfully", "response": source_id }

@router.put("/source/{source_id}", response_model=MessageResponse[ExploitSourceDTO|None])
async def edit_exploit_source(source_id: ExploitSourceID, data: ExploitSourcePushForm, db: DBSession):
    source_metadata = (await db.scalars(
        sqla.update(ExploitSource).where(ExploitSource.id == source_id)
        .values(**json_like(data)).returning(ExploitSource)
    )).one_or_none()
    if source_metadata is None:
        raise HTTPException(404, "Source file not found")
    await redis_conn.publish(redis_channels.exploit_source, "update")
    return { "message": "Exploit source updated successfully", "response": json_like(source_metadata, unset=True) }
