from models.exploit import *
from models.response import *
from models.enums import *
from models.config import *
from utils import *
from typing import List, Annotated
from fastapi import APIRouter, HTTPException, UploadFile, File, Form
from typing import Dict
from env import EXPLOIT_SOURCES_DIR
import tarfile, tempfile, shutil
from fastapi.responses import FileResponse
from exploitfarm.utils.config import ExploitConfig, check_exploit_config_exists
from exploitfarm.utils import calc_hash
from db import Exploit, DBSession, AttackExecution, sqla, ExploitSource, Flag, MANUAL_CLIENT_ID

router = APIRouter(prefix="/exploits", tags=["Exploits"])

@router.get("", response_model=List[ExploitDTO])
async def exploits_get(db: DBSession):
    config = await Configuration.get_from_db()
    
    exploits = (await db.execute(
        sqla.select(Exploit, AttackExecution)
        .outerjoin(AttackExecution, AttackExecution.exploit == Exploit)
        .where(
            AttackExecution.id.in_(
                sqla.select(sqla.func.max(AttackExecution.received_at))
                .where(AttackExecution.exploit == Exploit)
                .correlate(Exploit)
            )
        )
    )).all()
    
    for result in exploits:
        exploit, latest_attack = result.tuple()
        print(exploit, latest_attack) #TODO test this
        
        if latest_attack and config.SETUP_STATUS != SetupStatus.SETUP:
            max_timeout = 5 #Base timeout
            match config.ATTACK_MODE:
                case AttackMode.WAIT_FOR_TIME_TICK:
                    max_timeout += config.ATTACK_TIME_TICK_DELAY + config.TICK_DURATION
                case AttackMode.TICK_DELAY:
                    max_timeout += config.TICK_DURATION
                case AttackMode.LOOP_DELAY:
                    max_timeout += max(config.LOOP_ATTACK_DELAY, config.TICK_DURATION)
            exploit.status = ExploitStatus.disabled if (datetime_now() - latest_attack.received_at).total_seconds() > max_timeout else ExploitStatus.active
        
        yield ExploitDTO(
            **exploit.model_dump(mode="json"),
            last_execution_by = latest_attack.executed_by if latest_attack else None,
            last_update = latest_attack.received_at if latest_attack else exploit.created_at
        )

@router.post("", response_model=MessageResponse[ExploitDTO])
async def exploit_new_or_edit(data: ExploitAddForm, db):
    exploit = (await db.execute(
        sqla.insert(Exploit).values(json_like(data)).on_conflict_do_update(
            index_elements=[Exploit.id],
            set_=json_like(data)
        ).returning(Exploit)
    )).one()
    return { "message": "Exploit created/updated successfully", "response": exploit }

@router.delete("/{exploit_id}", response_model=MessageResponse[ExploitDTO])
async def exploit_delete(exploit_id: ExploitID, db: DBSession):
    
    exploit = (await db.scalars(sqla.select(Exploit).where(Exploit.id == exploit_id))).one_or_none()
    if not exploit:
        raise HTTPException(404, "Exploit not found")
    
    sources = (await db.scalars(
        sqla.delete(ExploitSource)
        .where(ExploitSource.exploit == exploit)
        .returning(ExploitSource.hash)
    )).all()
    
    for source in set(sources):
        file_path = os.path.join(EXPLOIT_SOURCES_DIR, f"{source}.tar.gz")
        if os.path.exists(file_path):
            os.remove(file_path)
    
    return { "message": "Exploit deleted successfully", "response": exploit }


@router.put("/{exploit_id}", response_model=MessageResponse[ExploitDTO])
async def exploit_edit(exploit_id: ExploitID, data: ExploitEditForm, db: DBSession):
    
    result = (await db.scalars(
        sqla.update(Exploit).where(Exploit.id == exploit_id)
        .values(**{k: v for k, v in json_like(data).items() if k != "created_by"})
        .returning(Exploit)
    )).all()
    
    if len(result) == 0:
        raise HTTPException(404, "Exploit not found")
    
    return { "message": "Exploit updated successfully", "response": result }

@router.post("/{exploit_id}/submit", response_model=MessageResponse[Dict[str, int]])
async def exploit_submit(exploit_id: ExploitID, data: List[ExploitSubmitForm], db: DBSession):
    config = await Configuration.get_from_db()
    
    exploit = (await db.scalars(sqla.select(Exploit).where(Exploit.id == exploit_id))).one_or_none()
    if not exploit:
        raise HTTPException(404, "Exploit not found")
    
    async def attack_exec_commit(parsed_data: Dict[str, str]) -> int:
        flags = extract_values_by_regex(config.FLAG_REGEX, parsed_data["flags"])
        del parsed_data["flags"]
        attack_execution = (await db.scalars(
            sqla.insert(AttackExecution)
                .values(exploit=exploit, k=parsed_data)
                .returning(AttackExecution)
        )).one()
        db.add(attack_execution) #Keep track of the attack execution edits TODO test this
        
        flags = (await db.scalars(
            sqla.insert(Flag)
                .values([Flag(flag=flag, attack=attack_execution) for flag in flags])
                .on_conflict_do_nothing(index_elements=[Flag.flag])
                .returning(Flag)
        )).all()
        
        if len(flags) == 0 and attack_execution.status == AttackExecutionStatus.done:
            attack_execution.status = AttackExecutionStatus.noflags
        return len(flags)
 
    results = await asyncio.gather(*[attack_exec_commit(data) for data in [json_like(ele) for ele in data]])
    return { "message": "Attacks results submitted successfully", "response": { "flags": sum(results) } }

@router.post("/submit", response_model=MessageResponse[Dict[str, int]])
async def exploit_submit(data: ManualSubmitForm, db: DBSession):
    config = await Configuration.get_from_db()
    
    flags = (data.flags if data.flags else [])
    flags.append(data.output if data.output else "")
    flags = extract_values_by_regex(config.FLAG_REGEX, flags)
    
    status = AttackExecutionStatus.done if len(flags) > 0 else AttackExecutionStatus.noflags
    attack_execution = (await db.scalars(
        sqla.insert(AttackExecution)
            .values(executed_by=MANUAL_CLIENT_ID, status=status)
            .returning(AttackExecution)
    )).one()
    
    flags = (await db.scalars(
        sqla.insert(Flag)
            .values([Flag(flag=flag, attack=attack_execution) for flag in flags])
            .on_conflict_do_nothing(index_elements=[Flag.flag])
            .returning(Flag)
    )).all()

    return { "message": "Attack results submitted successfully", "response": { "flags": len(flags) } }

@router.post("/source", response_model=MessageResponse[ExploitSourceID|None])
async def new_exploit_source(
    file: Annotated[UploadFile, File()],
    message: Annotated[str|None, Form()],
    os_type: Annotated[str|None, Form()],
    distro: Annotated[str|None, Form()],
    arch: Annotated[str|None, Form()],
    pushed_by: Annotated[UnHashedClientID|None, Form()],
    db: DBSession
):  
    with tempfile.TemporaryDirectory(ignore_cleanup_errors=True) as temp_dir:
        with tempfile.NamedTemporaryFile("w+b") as temp_file:
            try:
                while rBytes := await file.read(1024):
                    temp_file.write(rBytes)
                temp_file.seek(0)
                tfile = tarfile.open(fileobj=temp_file, mode="r:gz")
                tfile.extractall(path=temp_dir)
            except Exception as e:
                raise MessageResponseInvalidError("Invalid tar.gz file", str(e))
            if not check_exploit_config_exists(temp_dir):
                raise MessageResponseInvalidError("config.toml not found in the tar.gz file")
            try:
                expl_config = ExploitConfig.read(temp_dir)
            except Exception as e:
                raise MessageResponseInvalidError("Invalid config.toml file", str(e))
            exploit = (await db.scalars(sqla.select(Exploit).where(Exploit.id == expl_config.uuid))).one_or_none()
            if not exploit:
                raise HTTPException(404, "Exploit not found")
            try:
                hash_id = calc_hash(temp_dir)
            except Exception as e:
                raise MessageResponseInvalidError("Cannot calculate hash of exploit source", str(e))
            
            expl_src = (await db.scalars(
                sqla.insert(ExploitSource)
                    .values(
                        hash=hash_id,
                        message=message,
                        os_type=os_type,
                        distro=distro,
                        arch=arch,
                        exploit=exploit,
                        pushed_by=pushed_by
                    ).returning(ExploitSource)
            )).one()
            
            final_file_path = os.path.join(EXPLOIT_SOURCES_DIR, f"{hash_id}.tar.gz")
            if not os.path.exists(final_file_path):
                shutil.move(temp_file.name, final_file_path)
    
    return { "message": "Exploit Source pushed correctly", "response": expl_src.id }

@router.get("/{exploit_id}/source", response_model=List[ExploitSourceDTO])
async def exploit_source_list(exploit_id: ExploitID, db: DBSession):
    exploit = (await db.scalars(sqla.select(Exploit).where(Exploit.id == exploit_id))).one_or_none()
    if not exploit:
        raise HTTPException(404, "Exploit not found")
    
    return (await db.scalars(
        sqla.select(ExploitSource)
        .where(ExploitSource.exploit == exploit)
        .order_by(ExploitSource.pushed_at.desc())
    )).all()

@router.get("/source/{source_hash}/download", response_class=FileResponse)
async def download_exploit_source(source_hash: str):
    file_path = os.path.join(EXPLOIT_SOURCES_DIR, f"{source_hash}.tar.gz")
    if not os.path.exists(file_path):
        raise HTTPException(404, "Source file not found")
    return FileResponse(file_path)

@router.delete("/source/{source_id}", response_model=MessageResponse[ExploitSourceID])
async def delete_exploit_source(source_id: ExploitSourceID, db: DBSession):
    sources_metadata = (await db.scalars(
        sqla.select(ExploitSource).where(ExploitSource.hash == (
            sqla.select(ExploitSource.hash).where(ExploitSource.id == source_id)
        ))
    )).all()
    if len(sources_metadata) == 0:
        raise HTTPException(404, "Source file not found")
    
    can_delete_source_file = len(sources_metadata) <= 1
    file_path = os.path.join(EXPLOIT_SOURCES_DIR, f"{sources_metadata[0].hash}.tar.gz")
    
    if can_delete_source_file and os.path.exists(file_path):
        os.remove(file_path)
    
    for ele in sources_metadata:
        if ele.id == source_id:
            await db.delete(ele)
            break
    
    return { "message": "Source deleted successfully", "response": source_id }

@router.put("/source/{source_id}", response_model=MessageResponse[ExploitSourceDTO|None])
async def edit_exploit_source(source_id: ExploitSourceID, data: ExploitSourcePushForm, db: DBSession):
    source_metadata = (await db.scalars(
        sqla.update(ExploitSource).where(ExploitSource.id == source_id)
        .values(**json_like(data)).returning(ExploitSource)
    )).one_or_none()
    if source_metadata is None:
        raise HTTPException(404, "Source file not found")
    return { "message": "Exploit source updated successfully", "response": source_metadata }
